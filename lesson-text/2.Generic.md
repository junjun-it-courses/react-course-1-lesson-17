## Generic

Основная часть разработки заключается в создании компонентов, которые не только имеют четко 
определенные и согласованные API, но и могут использоваться повторно. Компоненты, с разными данными, предоставляют нам
гибкие возможности для создания больших и сложных проектов.

В таких языках, как C# и Java, одним из основных инструментов в наборе инструментов для создания повторно используемых
компонентов являются дженерики, то есть возможность создать компонент, который может работать с различными типами,
а не с одним. Это позволяет использовать такие компоненты с собственными(разными типами) собственные типы.


Для начала опишем функцию helloWorld через дженерик тип

> См. файл: lesson-files/generic/hello_world.ts

<hr>

Без дженериков нам нужно было бы передавать определенный тип, в данном случае number.

<pre>
function helloWorld(arg: number): number {
    return arg;
}
</pre>

<hr>

Также мы можем описать эту функцию через тип any, что даст нам больше гибкости, однако мы потеряем возможность
отслеживать типы, так как данная функция будет принимать любой тип.

<pre>
function helloWorld2(arg: any): any {
  return arg;
}
</pre>

<hr>

Вместо этого нам нужен способ захвата типа аргумента таким образом, чтобы мы могли также использовать его для 
обозначения того, что возвращается из функции.

```
function helloWorld3<Type>(arg: Type): Type {
  return arg;
}
```

В данном примере мы использовали какую-то переменную Type, не стоит путать с ключевым словом type, Type был использован
в качестве типа аргумента функции и типа возвращаемого функцией значения, а так же как и generic type смой функции.

Что это нам дает? 

Теперь у нас есть возможность указывать generic тип при вызове функции. Этот тип и будет использоваться вместо Type
в рамках текущего вызова.

```
let output = helloWorld3<string>("myString")
```

В данном случае в рамках текущего вызова функции helloWorld3 мы явно установили тип string, аналогично этот тип 
будет использован в качестве типа аргумента функции и типа возвращаемого значения функции. Так как при описании самой 
функции мы это указали, когда описывали тип аргумента и возвращаемого значения.

<hr>

Другой способ:

```
let output2 = helloWorld3("myString");
```

Он заключается в том чтобы не указывать тип при вызове generic функции явно, в данном примере все также будет работать
нормально, а тип данных переменной определится как строка, из-за того что в функцию helloWorld3 вызове мы передали 
строку, из нее и будет взят тип переменной.

Оба варианта использования достаточно удобны и самое главное то что мы не теряем контроль над типами которыми оперирует 
функция, так как они устанавливаются при вызове функции, а не при ее описании.


### Работа с переменными универсального типа

> См. файл: lesson-files/generic/identity.ts

Когда мы используем Generic то внутри функции мы работаем с данными, как будто они находятся в типе any или могут быть 
любого типа.

```
function identity<Type>(arg: Type): Type {
    return arg;
}
```

Но что будет если мы при каждом вызове функции хотим длину аргумента arg ? Мы явно напишем что-то в таком стиле.

```
function loggingIdentity<Type>(arg: Type): Type {
    console.log(arg.length);
    // Property 'length' does not exist on type 'Type'.
    return arg;
}
```

После того как мы выведем в консоль arg.length мы получим ошибку, так как в рамках этой функции не указано, что аргумент
arg имеет свойство length. Так как generic заменяет все без исключения типы функции, то возможно, при вызове этой
функции кто-то передаст не массив, а число - у которого нет свойства length. Поэтому мы и получаем такую ошибку.

<hr>

Давайте скажем что мы на самом деле хотели чтобы данная функция работала с массивами, данные которых мы хотим указывать
при вызове функции. Изменим немного код нашей функции, и в качестве типа аргумента и типа возвращаемого значения 
определим generic массив Type:[].

```
function loggingIdentityArr<Type>(arg: Type[]): Type[] {
    console.log(arg.length);
    return arg;
}
```

Так как теперь тип нашего аргумента это массив, то и свойство length у него есть, а значит ошибку мы больше не получим.
Можно описать функцию loggingIdentityArr как «общая функция loggingIdentityArr принимает параметр типа Type и аргумент
arg, который представляет собой массив типов, и возвращает массив типов».

<hr>

В качестве альтернативы, мы можем описать эту функцию следующим образом.

```
function loggingIdentityArrAlternative<Type>(arg: Array<Type>): Array<Type> {
  console.log(arg.length); // Array has a .length, so no more error
  return arg;
}
```

### Generic Classes

> См.файл: lesson-files/generic/generic_class.ts**

Предположим что у нас есть класс:

```
class Dog {
    constructor(public name: string, public age: number) {}

    public getVoice(): string {
        return 'GavGav'
    }
}
```

И мы хотим сделать из него generic класс:

```
class Cat<Type> {

    constructor(public name: Type, public age: Type) {}

    public getVoice(): string {
        return 'Meov Meov'
    }
}

const puppy = new Cat('Vladimir', '24');
const kitty = new Cat(100, 24);

puppy.getVoice();
kitty.getVoice();
```

Итак, после имени класса мы указываем generic тип, аналогично тому как мы указывали в примерах с функциями, после чего 
наши свойства класса меняют свои типы на ```<Type>```, в методе ```getVoice(): string``` ничего не изменяется так,
результатом его выполнения будет строка.

Теперь мы можем вызывать наш класс, с разными типами и это не повлияет на его работу, но мы все еще контролируем типы.

<hr>

Что если нам нужно передать несколько generic типов для свойств класса (это также будет работать и для функций).

```
class Cow<Type1, Type2> {

    constructor(public name: Type1, public age: Type2) {}

    public getVoice(): string {
        return 'Moo Moo'
    }
}

const cowMaleChild = new Cow('Vladimir', 20);
const cowFemaleChild = new Cow<string, number>('Vladimir', 25);
```

Тут все достаточно просто, все что нам нужно сделать так это при создании класса, в качестве generic типа передать
столько типов сколько нам нужно через запятую. Далее при создании экземпляра класса мы можем передавать аргументы 
в тех типах которые задумывали или указывать generic типы явно как в примере. И тот и другой способ полезны и доступы 
для использования.

<hr>

Добавим в наш класс Cow новый метод getAgeInMonths который будет работать с this.age как с числом, но так как тип данных
свойства age не описан мы можем получить ошибку о том что невозможно выполнить математическую операцию с переменной с 
неопределенным типом. Все что нам нужно сделать это ограничить Type2 таким образом, чтобы соответствовал типу данных
number. ```Type2 extends number```. Как вариант, мы могли бы завести доп переменную в методе ```getAgeInMonths()```
в которой проводили бы конвертацию в тип number и валидировали бы данные.

```
class Cow<Type1, Type2 extends number> {

    constructor(public name: Type1, public age: Type2) {}

    public getVoice(): string {
        return 'Moo Moo'
    }

    getAgeInMonths(): number {
        // const localAge: number = Number(this.age)
        // return localAge * 12;
    
        return this.age  * 12
    }
}

const cowMaleChild = new Cow('Vladimir', 20);
const cowFemaleChild = new Cow<string, number>('Vladimir', 25);
```